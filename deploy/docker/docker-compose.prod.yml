# =============================================================================
# Reach - Production Docker Compose
# Traefik reverse proxy with Let's Encrypt SSL via Cloudflare DNS
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Traefik Reverse Proxy
  # ---------------------------------------------------------------------------
  traefik:
    image: traefik:v3.3
    container_name: reach-proxy
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    networks:
      - proxy
    extra_hosts:
      # Allow Traefik to reach services on host network
      - "host.docker.internal:host-gateway"
    ports:
      # HTTP on port 80 (redirects to HTTPS)
      - "80:80"
      # HTTPS on 8443 (port 443 reserved for SSH client tunnels)
      - "8443:8443"
    environment:
      # Docker API version compatibility
      DOCKER_API_VERSION: "1.44"
      # Cloudflare API token for DNS-01 challenge
      CF_DNS_API_TOKEN: ${CF_DNS_API_TOKEN}
      ACME_EMAIL: ${ACME_EMAIL}
    volumes:
      # Docker socket for container discovery (read-only)
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # Traefik configuration
      - ./traefik/traefik.yml:/traefik.yml:ro
      - ./traefik/dynamic:/etc/traefik/dynamic:ro
      # Let's Encrypt certificate storage
      - letsencrypt:/letsencrypt
      # Timezone
      - /etc/localtime:/etc/localtime:ro
    labels:
      traefik.enable: "true"
      # Dashboard (optional - remove in high-security environments)
      traefik.http.routers.dashboard.rule: "Host(`${DOMAIN}`) && PathPrefix(`/traefik`)"
      traefik.http.routers.dashboard.service: "api@internal"
      traefik.http.routers.dashboard.entrypoints: "websecure"
      traefik.http.routers.dashboard.tls.certresolver: "cloudflare"
      traefik.http.routers.dashboard.middlewares: "dashboard-auth"
      # Basic auth for dashboard (generate with: htpasswd -nb admin password)
      traefik.http.middlewares.dashboard-auth.basicauth.users: "${TRAEFIK_DASHBOARD_AUTH}"
    healthcheck:
      test: ["CMD", "traefik", "healthcheck", "--ping"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ---------------------------------------------------------------------------
  # Frontend (Svelte SPA served by nginx)
  # ---------------------------------------------------------------------------
  frontend:
    build:
      context: ../../web
      dockerfile: Dockerfile
    container_name: reach-frontend
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    networks:
      - proxy
      - web
    environment:
      # API URL for client-side requests (routed through Traefik)
      PUBLIC_API_URL: "https://${DOMAIN}/api"
    volumes:
      - /etc/localtime:/etc/localtime:ro
    labels:
      traefik.enable: "true"
      # Main frontend route
      traefik.http.routers.frontend.rule: "Host(`${DOMAIN}`)"
      traefik.http.routers.frontend.entrypoints: "websecure"
      traefik.http.routers.frontend.tls.certresolver: "cloudflare"
      traefik.http.routers.frontend.middlewares: "frontend-chain@file"
      traefik.http.services.frontend.loadbalancer.server.port: "3000"
      # Lower priority so API routes match first
      traefik.http.routers.frontend.priority: "1"
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    depends_on:
      backend:
        condition: service_healthy

  # ---------------------------------------------------------------------------
  # Backend (Python MCP Server)
  # ---------------------------------------------------------------------------
  backend:
    build:
      context: ../..
      dockerfile: deploy/docker/Dockerfile.server
    container_name: reach-backend
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    # Use host network so backend can access SSH reverse tunnels on localhost
    network_mode: host
    environment:
      # Server settings
      REACH_HOST: ${REACH_HOST:-0.0.0.0}
      REACH_PORT: ${REACH_PORT:-8765}
      REACH_SSH_PORT: ${REACH_SSH_PORT:-2222}
      REACH_LOG_LEVEL: ${REACH_LOG_LEVEL:-INFO}
      # API authentication
      REACH_API_KEY: ${REACH_API_KEY}
      # R2 configuration (for file exchange)
      REACH_R2_ACCOUNT_ID: ${REACH_R2_ACCOUNT_ID:-}
      REACH_R2_ACCESS_KEY: ${REACH_R2_ACCESS_KEY:-}
      REACH_R2_SECRET_KEY: ${REACH_R2_SECRET_KEY:-}
      REACH_R2_BUCKET: ${REACH_R2_BUCKET:-}
      REACH_R2_REGION: ${REACH_R2_REGION:-auto}
      # Webhooks
      REACH_WEBHOOK_URL: ${REACH_WEBHOOK_URL:-}
      REACH_WEBHOOK_TIMEOUT: ${REACH_WEBHOOK_TIMEOUT:-10.0}
      REACH_WEBHOOK_MAX_RETRIES: ${REACH_WEBHOOK_MAX_RETRIES:-3}
      # Rate limiting
      REACH_RATE_LIMIT_RPM: ${REACH_RATE_LIMIT_RPM:-60}
      REACH_RATE_LIMIT_CONCURRENT: ${REACH_RATE_LIMIT_CONCURRENT:-10}
    volumes:
      # Persistent data (use bind mount for host network compatibility)
      - /var/lib/reach:/var/lib/reach
      # Logs
      - /var/log/reach:/var/log/reach
      # Timezone
      - /etc/localtime:/etc/localtime:ro
    # Note: Traefik labels don't work with host network mode
    # Backend routes are configured via Traefik file provider in traefik/dynamic/backend.yml
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8765/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# -----------------------------------------------------------------------------
# Networks
# -----------------------------------------------------------------------------
networks:
  # External-facing network (Traefik routes to services)
  proxy:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br_proxy

  # Web tier network (frontend <-> backend communication)
  web:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br_web

  # Internal network (backend <-> databases, future services)
  internal:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br_internal
    internal: true

# -----------------------------------------------------------------------------
# Volumes
# -----------------------------------------------------------------------------
volumes:
  # Let's Encrypt certificates
  letsencrypt:
    driver: local

  # Backend persistent data
  server-data:
    driver: local

  # Backend logs
  server-logs:
    driver: local
